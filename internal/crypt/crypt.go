/*******************************************************************************
* Copyright 2023 Stefan Majewsky <majewsky@gmx.net>
* SPDX-License-Identifier: GPL-3.0-only
* Refer to the file "LICENSE" for details.
*******************************************************************************/

// Package crypt provides a type-safe interface to the password hashing
// functionality in libxcrypt.
//
// Please keep the imports of this package as small as reasonably possible.
// All the code that is located or imported here ends up in the orchestrator
// binary that runs as root. Let's all do our part to keep the TCB small.
package crypt

import (
	"fmt"
	"strings"

	"github.com/sapcc/go-bits/logg"
)

const cryptPrefix = "{CRYPT}"

// PasswordHasher is the main interface provided by this package.
// It can be swapped for a double in tests.
type PasswordHasher interface {
	// HashPassword produces a password hash in the format expected by slapd.
	HashPassword(password string) string

	// WrapPasswordHash converts a password hash generated by libxcrypt
	// into the format expected by slapd.
	WrapPasswordHash(hash string) string

	// CheckPasswordHash verifies the given password against the
	// stored hash in nearly constant time.
	CheckPasswordHash(password, passwordHash string) bool

	// IsWeakHash checks whether this password hash should be regenerated with a
	// stronger method at the next opportunity.
	IsWeakHash(passwordHash string) bool
}

// NewPasswordHasher returns the real PasswordHasher implementation.
func NewPasswordHasher() (PasswordHasher, error) {
	err := llFeatureTest()
	if err != nil {
		return nil, err
	}

	var h hasher
	h.PreferredMethod = llPreferredMethod()

	bogusPassword, err := llGenerateSalt(h.PreferredMethod)
	if err != nil {
		return nil, fmt.Errorf("while generating a bogus password: %w", err)
	}
	bogusPasswordHash, err := llCrypt(bogusPassword, bogusPassword)
	if err != nil {
		return nil, fmt.Errorf("while generating a bogus password hash: %w", err)
	}
	h.BogusPasswordHash = cryptPrefix + bogusPasswordHash

	// TODO: consider allowing manual override of the preferred method, to offer
	// an upgrade path between libcrypt implementations with different preferences
	return h, nil
}

type hasher struct {
	PreferredMethod   string
	BogusPasswordHash string
}

// HashPassword implements the PasswordHasher interface.
func (h hasher) HashPassword(password string) string {
	salt, err := llGenerateSalt(h.PreferredMethod)
	if err != nil {
		logg.Fatal("cannot generate salt for password hashing: %s", err.Error())
	}
	hash, err := llCrypt(password, salt)
	if err != nil {
		logg.Fatal("cannot hash password: %s", err.Error())
	}

	return h.WrapPasswordHash(hash)
}

// WrapPasswordHash implements the PasswordHasher interface.
func (h hasher) WrapPasswordHash(hash string) string {
	// slapd expects an extra {CRYPT} prefix for password hashes generated by libcrypt
	return cryptPrefix + hash
}

// CheckPasswordHash implements the PasswordHasher interface.
func (h hasher) CheckPasswordHash(password, passwordHash string) bool {
	// When this method is called on a non-existing user, i.e. the passwordHash is
	// the empty string, do not leak this fact to unauthorized users through the
	// timing side channel. Instead, we check the input against a bogus password
	// to take a comparable amount of time, then return false regardless.
	userExists := true
	if passwordHash == "" {
		userExists = false
		passwordHash = h.BogusPasswordHash
	}

	// strip the required prefix that we attached at the end of HashPassword()
	passwordHash, hasPrefix := strings.CutPrefix(passwordHash, cryptPrefix)
	if !hasPrefix {
		return false
	}

	// if the password is correct, rehashing with the same settings as in the hash
	// should reproduce the hash
	rehashed, err := llCrypt(password, passwordHash)
	if err != nil {
		logg.Error("cannot hash password for verification: %s", err.Error())
		return false
	}
	return userExists && rehashed == passwordHash
}

// IsWeakHash implements the PasswordHasher interface.
func (h hasher) IsWeakHash(passwordHash string) bool {
	passwordHash, hasPrefix := strings.CutPrefix(passwordHash, cryptPrefix)
	if !hasPrefix {
		return false
	}

	return !strings.HasPrefix(passwordHash, h.PreferredMethod)
}
